# 《物联网实训课》教学讲稿

**课程主题**: Ubuntu交叉编译环境搭建与Makefile编写
**授课时长**: 20分钟
**授课对象**: 物联网工程专业本科生（无Linux基础）
**配套PPT**: 18页

---

## 【导入环节】(0:00 - 3:00)

### 第1页讲解 (0:00 - 0:45)

同学们好，今天我们进行物联网实训课的学习。

这节课的主题是"ARM交叉编译环境搭建与Makefile编写"。听起来可能有点陌生，但别担心，我会一步一步带大家完成。

简单来说，今天我们要学习的是：如何在自己的电脑上编写程序，然后让这个程序能在ARM开发板上运行。这是嵌入式开发的基础技能，也是物联网工程师必须掌握的能力。

---

### 第2页讲解 (0:45 - 1:30)

我们先来看一下今天的学习目标。

**知识目标**有三个：
- 第一，理解什么是交叉编译，为什么需要它；
- 第二，掌握arm-linux-gcc工具链的安装和配置方法；
- 第三，理解Makefile的基本语法。

**能力目标**也是三个：
- 能够独立搭建交叉编译环境；
- 能够编写中等复杂度的Makefile；
- 能够把程序编译后部署到开发板运行。

今天的课程大约20分钟，我们会依次讲解开发板介绍、Linux基础命令、交叉编译环境搭建，以及Makefile编写。内容比较紧凑，大家跟紧节奏。

---

### 第3页讲解 (1:30 - 3:00)

好，首先我想问大家一个问题：我们现在用的电脑是什么处理器？

对，是Intel或者AMD的处理器，属于x86或x64架构。

那我们今天要操作的tiny6410开发板呢？它用的是ARM架构的处理器。

这里有一个关键问题：**这两种架构是不兼容的**。

打个比方帮助大家理解：
- x86架构就像"普通话"
- ARM架构就像"粤语"

虽然都是程序语言，但是"说普通话的程序"，ARM处理器是"听不懂"的。

那怎么办呢？我们需要一个"翻译官"——这就是**交叉编译器**。

交叉编译的意思是：在一种架构的机器上（我们的x86电脑），编译出另一种架构（ARM）能够运行的程序。

我们今天要安装的**arm-linux-gcc**，就是这个"翻译官"的名字。

大家看PPT上的示意图：左边是我们的开发电脑，中间是交叉编译器，右边是ARM开发板。程序经过编译器"翻译"后，就能在开发板上运行了。

---

## 【开发板介绍】(3:00 - 7:00)

### 第4页讲解 (3:00 - 4:20)

接下来我们认识一下今天的目标平台——tiny6410开发板。

这款开发板的核心是三星的S3C6410芯片，采用ARM11架构，主频667MHz。这个性能相当于什么呢？大概相当于2008年左右的智能手机，比如当年的iPhone 3G就是用的类似架构。

存储方面，它有256MB的DDR内存和2GB的NAND Flash存储，还支持SD卡扩展。

接口非常丰富：
- USB接口，用于连接电脑或外设
- 以太网口，可以进行网络调试
- 串口，这是调试时最重要的接口
- 还有LCD接口、音频接口、GPIO扩展接口等

虽然以现在的眼光看，这个配置比较低，但对于学习嵌入式开发来说，它是非常经典的入门平台，很多概念和方法都是通用的。

---

### 第5页讲解 (4:20 - 5:40)

现在我们来认识一下开发板的各个接口。

（指向PPT图片）

大家看这张实物图：

- 这里是**电源接口**，使用5V 2A的直流电源；
- 这个DB9接口是**串口**，我们调试时要用它来查看开发板的输出信息；
- 这是**USB Device接口**，用来连接电脑下载程序；
- 旁边的**USB Host接口**可以连接U盘、鼠标等设备；
- 这个RJ45接口是**网口**，可以通过网络进行调试，效率很高；
- 侧面有**SD卡槽**，可以用于系统启动或存储扩展；
- 还有**JTAG接口**，这是硬件调试用的。

板子上还有几个指示灯：电源灯、运行状态灯，还有几个用户可编程的LED，我们可以写程序控制它们闪烁。

如果有条件，建议大家能拿到实物，实际操作印象会更深刻。

---

### 第6页讲解 (5:40 - 7:00)

开发板和电脑之间有三种主要的连接方式。

**第一种是串口连接**，这是必须的。
- 用途是查看启动信息、进行命令行交互
- 需要一根USB转串口线
- 在电脑上用minicom、putty或SecureCRT这些软件来连接
- 通信参数是115200波特率，8数据位，无校验，1停止位

**第二种是USB连接**。
- 主要用于下载程序到开发板
- 友善之臂提供了专门的dnw工具

**第三种是网络连接**，这是我推荐的方式。
- 可以使用NFS（网络文件系统）挂载
- 好处是不用反复烧写程序，修改后立即就能测试
- 对于开发调试来说效率最高

如果条件允许，建议大家优先使用网络方式进行开发。

---

## 【Linux基础命令】(7:00 - 10:00)

### 第7页讲解 (7:00 - 8:00)

接下来我们学习几个Linux基础命令。由于很多同学之前没用过Linux，所以这部分我会讲得详细一些。

**第一个命令是pwd**，Print Working Directory的缩写，用来显示当前所在的目录。

```
$ pwd
/home/student
```

**第二个命令是cd**，Change Directory，用来切换目录。

```
$ cd /usr/local    # 进入指定目录
$ cd ..            # 返回上级目录
$ cd ~             # 返回用户主目录
```

**第三个命令是ls**，List，用来列出目录内容。

```
$ ls       # 简单列出文件名
$ ls -l    # 显示详细信息
$ ls -la   # 包含隐藏文件
```

**第四个命令是mkdir**，Make Directory，创建目录。

```
$ mkdir test       # 创建单个目录
$ mkdir -p a/b/c   # 创建多级目录，-p表示自动创建父目录
```

这四个命令是最基础的，请大家务必记住。

---

### 第8页讲解 (8:00 - 9:00)

接下来三个命令在安装交叉编译器时会用到，非常重要。

**第一个是tar命令**，用于解压文件。

交叉编译器通常是.tar.gz格式的压缩包，解压命令是：

```
$ tar -xvzf 文件名.tar.gz
```

参数的含义是：
- -x：解压
- -v：显示过程
- -z：处理gzip压缩
- -f：指定文件

如果要解压到指定目录，加上 -C 参数：

```
$ tar -xvzf 文件名.tar.gz -C /usr/local/
```

**第二个是export命令**，用于设置环境变量。

```
$ export PATH=$PATH:/new/path
```

这行命令的意思是：把/new/path这个路径添加到PATH环境变量中。

**第三个是source命令**，用于使配置文件立即生效。

```
$ source ~/.bashrc
```

修改了配置文件后，必须执行这个命令，或者重新打开终端，配置才会生效。

---

### 第9页讲解 (9:00 - 10:00)

还有两个概念需要了解。

**第一是绝对路径和相对路径**：
- 绝对路径：从根目录/开始，比如 /usr/local/arm
- 相对路径：从当前目录开始，比如 ./bin 或 ../lib

**建议**：在配置环境变量时，一定要使用绝对路径，这样更可靠，不容易出错。

**第二是几个重要的系统目录**：
- /usr/local/ —— 通常用来安装用户自己的软件
- /home/用户名/ —— 用户的主目录
- ~/.bashrc —— 用户的bash配置文件，波浪号~代表主目录

**第三是sudo命令**，用于以管理员身份执行操作。

```
$ sudo mkdir /usr/local/arm
```

在/usr/local这样的系统目录下创建文件夹，需要管理员权限，所以要加sudo。系统会提示输入密码。

好，Linux基础命令就介绍到这里。下面进入重点内容——交叉编译环境的搭建。

---

## 【交叉编译环境搭建】(10:00 - 15:00)

### 第10页讲解 (10:00 - 11:30)

现在开始搭建交叉编译环境。整个过程分为三步。

**第一步：获取并安装交叉编译器**

首先，我们需要获取编译器安装包。文件名是：
arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz

这个文件大约100MB，可以从友善之臂官网下载，或者使用课程提供的资源包。

接下来，创建安装目录：

```bash
$ sudo mkdir -p /usr/local/arm
```

这里sudo是因为/usr/local需要管理员权限，-p参数确保如果目录已存在不会报错。

然后解压安装：

```bash
$ sudo tar -xvzf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz -C /usr/local/arm
```

-C 参数指定解压到/usr/local/arm目录下。

解压完成后，我们来验证一下：

```bash
$ ls /usr/local/arm/
4.5.1

$ ls /usr/local/arm/4.5.1/bin/
arm-linux-gcc  arm-linux-g++  arm-linux-ld  ...
```

能看到这些文件，说明解压成功了。

---

### 第11页讲解 (11:30 - 13:00)

**第二步：配置环境变量**

为什么要配置PATH环境变量呢？

因为现在arm-linux-gcc命令在/usr/local/arm/4.5.1/bin/目录下，如果不配置PATH，每次使用都要输入完整路径，非常麻烦。

配置方法是编辑~/.bashrc文件，在末尾添加一行。

**方法一**，使用echo命令追加（推荐新手使用）：

```bash
$ echo 'export PATH=$PATH:/usr/local/arm/4.5.1/bin' >> ~/.bashrc
```

**方法二**，使用文本编辑器：

```bash
$ gedit ~/.bashrc
```

打开后，在文件最后添加这一行：
```
export PATH=$PATH:/usr/local/arm/4.5.1/bin
```

保存退出。

**然后，让配置立即生效**：

```bash
$ source ~/.bashrc
```

**最后，验证配置是否成功**：

```bash
$ echo $PATH
```

如果输出中能看到/usr/local/arm/4.5.1/bin，就说明配置成功了。

还可以直接测试编译器版本：

```bash
$ arm-linux-gcc -v
```

如果显示gcc版本信息，恭喜你，环境配置成功！

---

### 第12页讲解 (13:00 - 14:00)

**第三步：编译第一个ARM程序**

让我们写一个简单的Hello World程序来验证环境。

创建文件hello.c，内容如下：

```c
#include <stdio.h>

int main(void)
{
    printf("Hello, tiny6410!\n");
    printf("ARM交叉编译成功！\n");
    return 0;
}
```

使用交叉编译器编译：

```bash
$ arm-linux-gcc -o hello hello.c
```

编译完成后，我们来验证生成的是不是ARM程序：

```bash
$ file hello
hello: ELF 32-bit LSB executable, ARM, version 1...
```

看到了吗？显示的是**ARM**！

我们再对比一下系统自带的程序：

```bash
$ file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64...
```

系统的ls命令显示的是**x86-64**。

这就说明：
- 我们编译的hello是ARM程序，可以在开发板上运行
- 系统的ls是x86程序，只能在PC上运行

到这里，交叉编译环境就搭建成功了！

---

### 第13页讲解 (14:00 - 15:00)

在实际操作中，大家可能会遇到一些问题。我来讲几个常见的。

**问题一**："command not found"

```
$ arm-linux-gcc
bash: arm-linux-gcc: command not found
```

原因是PATH环境变量没有正确配置。
解决方法：检查~/.bashrc文件，确认export那行是否正确，然后重新执行source命令。

**问题二**："Permission denied"

```
$ mkdir /usr/local/arm
mkdir: cannot create directory: Permission denied
```

原因是忘记加sudo。
解决方法：在命令前面加上sudo。

**问题三**：最容易犯的错误——**漏掉冒号**

```bash
# 错误写法
export PATH=$PATH/usr/local/arm/4.5.1/bin

# 正确写法
export PATH=$PATH:/usr/local/arm/4.5.1/bin
```

注意看，错误写法漏掉了$PATH后面的冒号。就这一个字符的差别，结果完全不同。

**【课程思政：代码规范的重要性】**

说到这里，我想跟大家分享一点。

在编程和工程领域，**细节决定成败**。一个冒号、一个分号、一个空格，都可能导致程序无法运行。

历史上有很多因为代码细节导致的重大事故。比如1996年，欧洲航天局的阿丽亚娜5号火箭发射后37秒就爆炸了，原因是什么？是程序中一个64位浮点数转换为16位整数时发生了溢出。就这么一个小小的数值转换问题，导致了价值5亿美元的火箭化为乌有。

所以同学们，从现在开始就要养成严谨规范的编程习惯。**写代码不是写差不多就行，而是要精确、要规范**。

---

## 【Makefile编写】(15:00 - 19:00)

### 第14页讲解 (15:00 - 16:00)

接下来我们学习Makefile的编写。

**为什么需要Makefile？**

想象一下，如果你的项目有几十个源文件，每次编译都要手动输入几十条gcc命令，那太麻烦了。而且，如果只修改了其中一个文件，我们希望只重新编译这一个，而不是全部重来。

Makefile就是解决这个问题的。它能：
- 自动化编译流程
- 管理多文件项目
- 实现增量编译，只编译修改过的文件

**Makefile的基本结构**非常简单，就三个要素：

```makefile
目标: 依赖
	命令
```

- **目标**：你想生成的文件
- **依赖**：生成目标需要的文件
- **命令**：具体的编译命令

来看一个最简单的例子：

```makefile
hello: hello.c
	arm-linux-gcc -o hello hello.c

clean:
	rm -f hello
```

**特别注意**：命令前面必须是**Tab键**，不能是空格！这是很多新手会犯的错误。如果用了空格，make会报错"missing separator"。

---

### 第15页讲解 (16:00 - 17:00)

接下来我们学习Makefile中的变量。

**自定义变量**可以让Makefile更灵活、更易维护：

```makefile
CC = arm-linux-gcc
CFLAGS = -Wall -O2
TARGET = myapp

$(TARGET): main.c
	$(CC) $(CFLAGS) -o $(TARGET) main.c
```

$(CC)就是引用变量CC的值。这样写的好处是，如果要换编译器，只需要改一处。

**自动变量**是Makefile的精华，能让代码更简洁。最常用的有三个：

| 变量 | 含义 | 例子 |
|------|------|------|
| $@ | 目标文件名 | 如果目标是myapp，$@就是myapp |
| $^ | 所有依赖文件 | 如果依赖是main.o utils.o，$^就是它们 |
| $< | 第一个依赖文件 | 如果依赖是main.c utils.h，$<就是main.c |

使用自动变量改写后：

```makefile
myapp: main.o utils.o
	$(CC) -o $@ $^

main.o: main.c
	$(CC) -c -o $@ $<
```

$@代表myapp，$^代表main.o utils.o，$<代表main.c。

这三个自动变量请大家务必记住，写Makefile会经常用到。

---

### 第16页讲解 (17:00 - 18:00)

现在我们来看一个完整的多文件项目Makefile。

假设项目结构是这样的：
```
project/
├── main.c      # 主程序
├── utils.c     # 工具函数
├── utils.h     # 头文件
└── Makefile
```

完整的Makefile如下：

```makefile
# 物联网实训 - 交叉编译Makefile示例
# 目标平台：tiny6410 (ARM11)

CC = arm-linux-gcc
CFLAGS = -Wall -O2

TARGET = myapp
OBJS = main.o utils.o

# 链接生成可执行文件
$(TARGET): $(OBJS)
	$(CC) -o $@ $^

# 模式规则：所有.c文件编译为.o文件
%.o: %.c
	$(CC) $(CFLAGS) -c -o $@ $<

# 头文件依赖
main.o: utils.h
utils.o: utils.h

# 伪目标：清理编译产物
.PHONY: clean
clean:
	rm -f $(TARGET) $(OBJS)
```

我来解释几个关键点：

**%.o: %.c** 是模式规则，%是通配符。意思是：任何.o文件都可以由同名的.c文件编译得到。有了这条规则，就不用为每个源文件单独写编译命令了。

**.PHONY: clean** 声明clean是伪目标。因为clean不是一个真实的文件，如果不声明，当目录下恰好有个叫clean的文件时，make会认为目标已存在而不执行。

这个Makefile模板大家可以直接拿去用，根据自己的项目修改文件名就行。

---

### 第17页讲解 (18:00 - 19:00)

最后讲一下Makefile的最佳实践。

**第一，善用模式规则**。%.o: %.c 这样的规则可以匹配所有源文件，避免重复代码。

**第二，使用.PHONY声明伪目标**。clean、all这些不生成实际文件的目标都应该声明为伪目标。

**第三，遵循变量命名约定**：
- CC：C编译器
- CXX：C++编译器
- CFLAGS：C编译选项
- LDFLAGS：链接选项

这些是约定俗成的名字，遵循约定能让别人更容易读懂你的Makefile。

**【课程思政：工匠精神】**

讲完了Makefile的技术内容，我想跟大家聊聊"工匠精神"。

大家看我们写Makefile的过程：
- 最开始，我们可能直接写死所有命令——能用就行；
- 然后，我们学会用变量、自动变量——代码更简洁了；
- 最后，我们使用模式规则、遵循约定——代码变得优雅、专业。

这其实就是**工匠精神**的三个层次：
1. **能用**：初学者心态
2. **好用**：工程师思维
3. **优雅**：匠人境界

写代码不仅仅是让程序跑起来，更要追求代码的质量、可读性、可维护性。

再说一点。我们今天学的交叉编译技术，支撑着整个嵌入式行业的发展。华为的海思芯片、龙芯、飞腾等国产处理器，它们的软件开发都离不开交叉编译。

作为物联网工程专业的学生，你们将来可能会参与到国产芯片、国产操作系统的开发中。掌握这些基础技能，不仅是为了应付考试，更是为了将来能为国家的自主可控贡献力量。

好，Makefile的内容就讲到这里。

---

## 【总结与作业】(19:00 - 20:00)

### 第18页讲解 (19:00 - 20:00)

最后我们来总结一下今天学习的内容。

**知识点回顾**：
1. tiny6410开发板的基本架构——ARM11处理器、主要接口
2. Linux常用命令——cd、ls、tar、export、source
3. 交叉编译环境搭建——三步走：解压、配置PATH、验证
4. Makefile基础——三要素、变量、自动变量$@、$^、$<

**实验任务**：

课后请大家完成以下任务：

1. 在Ubuntu虚拟机中搭建arm-linux-gcc交叉编译环境
2. 编写hello.c程序并进行交叉编译，用file命令验证
3. 编写一个包含3个源文件的小项目（比如main.c、calc.c、calc.h），并撰写Makefile
4. （选做）如果有开发板，尝试通过NFS把程序部署到开发板上运行

**参考资源**：
- GNU Make官方手册
- 友善之臂Wiki文档
- 课程实验指导书

如果在实验过程中遇到问题，可以先尝试自己排查，查看报错信息，搜索解决方案。实在解决不了的，可以在课程群里讨论或者来办公室找我。

好，今天的课就到这里，谢谢大家！

---

## 附录：讲稿时间节点汇总

| 时间段 | 页码 | 内容主题 | 时长 |
|--------|------|----------|------|
| 0:00-0:45 | 第1页 | 课程封面 | 45秒 |
| 0:45-1:30 | 第2页 | 学习目标 | 45秒 |
| 1:30-3:00 | 第3页 | 交叉编译概念 | 90秒 |
| 3:00-4:20 | 第4页 | tiny6410硬件架构 | 80秒 |
| 4:20-5:40 | 第5页 | 开发板接口图解 | 80秒 |
| 5:40-7:00 | 第6页 | 连接方式 | 80秒 |
| 7:00-8:00 | 第7页 | Linux命令（一） | 60秒 |
| 8:00-9:00 | 第8页 | Linux命令（二） | 60秒 |
| 9:00-10:00 | 第9页 | 路径与权限 | 60秒 |
| 10:00-11:30 | 第10页 | 编译器安装 | 90秒 |
| 11:30-13:00 | 第11页 | 环境变量配置 | 90秒 |
| 13:00-14:00 | 第12页 | Hello World实战 | 60秒 |
| 14:00-15:00 | 第13页 | 常见问题+思政1 | 60秒 |
| 15:00-16:00 | 第14页 | Makefile基础 | 60秒 |
| 16:00-17:00 | 第15页 | 变量与自动变量 | 60秒 |
| 17:00-18:00 | 第16页 | 多文件项目 | 60秒 |
| 18:00-19:00 | 第17页 | 最佳实践+思政2 | 60秒 |
| 19:00-20:00 | 第18页 | 总结与作业 | 60秒 |

---

## 附录：课程思政元素总结

### 思政点1：代码规范（第13页，约14:00）

**融入时机**：讲解"漏掉冒号"这个常见错误时

**核心内容**：
- 细节决定成败
- 阿丽亚娜5号火箭爆炸案例
- 养成严谨规范的编程习惯

**教学目标**：培养学生的严谨态度和规范意识

---

### 思政点2：工匠精神（第17页，约18:00）

**融入时机**：总结Makefile最佳实践时

**核心内容**：
- 代码的三个境界：能用→好用→优雅
- 工匠精神的内涵
- 国产芯片与自主可控

**教学目标**：激发学生的职业使命感和家国情怀

---

## 附录：可能的课堂互动问题

1. 【第3页】"有没有同学知道ARM和x86的区别？"
2. 【第4页】"大家用的手机是什么处理器？"（引出ARM在移动设备的广泛应用）
3. 【第7页】"有没有同学之前用过Linux？"
4. 【第13页】"大家觉得写代码最容易犯什么错误？"
5. 【第14页】"如果有100个源文件，每次都手动编译，大家觉得怎么样？"
