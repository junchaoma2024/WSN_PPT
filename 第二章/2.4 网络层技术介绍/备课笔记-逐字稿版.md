# 第二章 2.4 网络层技术介绍 - 备课笔记（逐字稿版）

## 课程信息
- **章节**：2.4 网络层技术介绍
- **总课时**：4课时（200分钟），分2次课
- **前导知识**：2.3节 MAC层技术
- **教学目标**：掌握WSN路由协议的分类与核心协议原理

---

# 第一次课（第1-2课时，100分钟）

---

## 2.4.1 网络层概述与路由基础（40分钟）

### 一、网络层在WSN中的作用（10分钟）

同学们好，今天我们开始学习第二章的第四节——网络层技术介绍。

大家先回忆一下，上一节课我们学了什么？对，MAC层。MAC层解决的是"多个节点如何在共享信道上有序通信"的问题，我们学了CSMA/CD、CSMA/CA、S-MAC、T-MAC等协议。通过MAC层，我们已经能够让两个相邻的节点之间成功地收发数据帧了。

但是，现在有一个新问题：如果源节点和目标节点不是邻居，不在彼此的通信范围内，怎么办？比如说，一个传感器节点检测到火灾，它需要把数据传给几百米外的基站，但它的通信距离只有几十米。这个时候怎么办？

对，需要通过中间节点转发，一跳一跳地传过去。这就是网络层要解决的核心问题——路由（Routing）。

我们先在协议栈中定位一下网络层的位置。从下往上看：物理层负责信号的传输，数据链路层（MAC层）负责相邻节点间的可靠帧传输，网络层负责从源到目的的路径选择和数据转发。简单说，物理层管的是"怎么把比特发出去"，MAC层管的是"邻居之间怎么通信"，网络层管的是"怎么找到一条路，把数据从源头送到目的地"。

网络层的核心功能有三个：
1. **路由选择（Routing）**：确定数据包从源节点到目标节点的传输路径
2. **数据转发（Forwarding）**：每个中间节点根据路由信息将数据包转发给下一跳
3. **拥塞控制**：当网络负载过大时，避免数据丢失

在传感器网络中，网络层还有一些特殊的要求。最重要的一点是：WSN的路由设计必须以**能量效率**为首要目标。因为传感器节点是电池供电的，能量用完就没了。我们不能像传统网络那样只追求最短路径或最低延迟，还必须考虑怎么让整个网络活得更久。

另一个重要的特殊性是WSN是**以数据为中心**的。什么意思呢？在传统网络中，我们关心的是"从IP地址A到IP地址B"，每个节点有唯一的地址。但在WSN中，我们并不关心是哪个节点发的数据，我们关心的是"温度超过50度的区域在哪里"。这是一个根本性的思维转变，我们后面讲的很多协议都体现了这个特点。

### 二、传统路由基础回顾（15分钟）

在深入WSN路由之前，我们先快速回顾一下传统网络的路由基础知识，这样大家才能更好地理解WSN路由的特殊之处。

**路由的基本概念**

路由（Routing）就是为数据包选择一条从源到目的的路径。这个过程需要每个网络节点（路由器）维护一个路由表（Routing Table）。

路由表里存什么呢？主要是三个信息：
- **目的地址**：我要去哪里
- **下一跳（Next Hop）**：下一步应该把数据包发给谁
- **代价（Cost/Metric）**：到达目的地的代价是多少（跳数、延迟、带宽等）

举个例子，假设节点X的路由表是这样的：

| 目的地 | 下一跳 | 跳数 |
|--------|--------|------|
| A      | B      | 2    |
| C      | D      | 3    |
| E      | B      | 4    |

当节点X收到一个要发往节点A的数据包时，它查路由表，发现"去A的话，下一跳是B"，于是把数据包转发给B。B收到后再查自己的路由表，继续转发，最终到达A。

**传统路由算法**

传统网络主要有两类路由算法：

第一类是**距离向量算法（Distance Vector）**。每个节点维护一个到所有目的地的距离向量，并定期与邻居交换。典型协议是RIP。它的特点是：简单，但收敛慢，可能出现"计数到无穷"的问题。

第二类是**链路状态算法（Link State）**。每个节点通过洪泛获取全网拓扑信息，然后用Dijkstra算法计算最短路径。典型协议是OSPF。它的特点是：收敛快，但需要更多的存储和计算资源。

这两种算法在传统网络中工作得很好，但是它们有一些共同的假设：
- 节点（路由器）资源充足——有足够的CPU、内存和电力
- 网络拓扑相对稳定——路由器不会经常故障
- 每个节点有唯一的IP地址
- 通信模式是端到端的，点对点的

大家想一想，WSN满足这些假设吗？

不满足。传感器节点CPU弱、内存小、电池有限；节点可能因为能量耗尽随时退出；我们不关心节点的地址，关心数据的内容；通信模式是多对一的汇聚模式——很多节点的数据汇聚到一个基站。

所以，传统的路由算法不能直接用在WSN中，我们需要专门为WSN设计的路由协议。

### 三、WSN路由的特殊挑战（10分钟）

下面我们详细分析一下WSN路由设计面临的五大挑战。

**第一个挑战：能量受限**

这是最核心的挑战。传感器节点通常由电池供电，电池容量有限，而且在很多部署场景下（比如深山老林、战场、管道内部），电池是不可更换和充电的。一旦能量耗尽，节点就"死"了。

这意味着路由设计的首要目标不是"最快"，而是"最省电"。更准确地说，我们不仅要最小化单个节点的能耗，还要均衡全网的能耗，避免某些节点过早死亡导致网络分割。

打个比方，如果有一条"最短路径"经过节点A，所有数据都走这条路，A的电池很快就耗尽了。A一死，这条路就断了，即使网络中其他节点还有很多能量，网络功能也受损了。所以，好的路由协议要像"轮班制"一样，让不同的节点轮流承担转发任务。

**第二个挑战：拓扑动态变化**

WSN的网络拓扑是不断变化的。变化的原因有很多：
- 节点能量耗尽，退出网络
- 新节点加入网络
- 环境变化导致信道质量波动（比如温度、湿度变化影响无线信号）
- 节点可能发生物理移动（某些场景下）

这意味着路由协议必须能够快速适应拓扑变化，重新建立路由。传统路由中那种"算好了就用很久"的模式不太适用。

**第三个挑战：数据冗余**

WSN通常是密集部署的。什么意思？就是在一个区域里撒了很多很多传感器节点，相邻节点之间的距离很近。这些相邻节点监测的是同一个区域，采集的数据往往是相似甚至相同的。

如果每个节点都原样转发自己的数据，那大量的冗余数据会浪费宝贵的带宽和能量。所以，好的路由协议应该支持**数据融合（Data Aggregation）**——在中间节点对数据进行合并、压缩，减少传输量。

比如，一个区域10个节点都测到温度是25度，与其10个节点各传一次"25度"，不如让一个代表节点传一次"这个区域温度25度"就够了。

**第四个挑战：以数据为中心**

传统网络的路由是"以地址为中心"的——我要把数据从IP地址10.0.0.1送到192.168.1.1。但WSN是"以数据为中心"的——基站说"我想要温度超过50度的数据"，它不关心这个数据是哪个节点发的。

这种以数据为中心的模式要求路由协议能够基于数据的内容和属性来做路由决策，而不仅仅是基于地址。

**第五个挑战：可扩展性**

WSN的节点数量可能很大，从几十个到几千个。路由协议必须能够在大规模网络中高效运行。这要求：
- 路由维护的通信开销不能随节点数线性增长
- 路由决策应该是分布式、局部的，不依赖全局信息
- 支持自组织，不需要人工配置

**总结：WSN路由 vs 传统路由**

让我们用一个对比表来总结：

| 特性     | 传统网络路由         | WSN路由              |
|----------|---------------------|---------------------|
| 优化目标 | 最短路径/最低延迟     | 最低能耗/最长网络寿命 |
| 寻址方式 | IP地址唯一标识       | 以数据为中心         |
| 节点资源 | 资源丰富             | 资源极度受限         |
| 网络拓扑 | 相对稳定             | 动态频繁变化         |
| 数据模式 | 点对点               | 多对一（多源汇聚）   |
| 数据融合 | 不需要               | 非常重要             |
| 可扩展性 | 层次化地址（子网）   | 自组织、分布式       |

好，现在大家应该理解了为什么WSN需要专门的路由协议。下面我们来看看WSN路由协议的分类体系。

### 四、路由协议分类体系（5分钟）

WSN路由协议有很多种分类方式，最常用的是按网络结构来分。

**第一类：平面路由（Flat Routing）**

在平面路由中，所有节点的地位是平等的，没有特殊的节点。每个节点既是数据产生者，也是数据转发者。

代表协议有：Flooding（泛洪）、Gossiping（闲聊）、SPIN（自适应信息传播）、DD（定向扩散）。

这类协议的优点是简单、不需要复杂的网络组织；缺点是可扩展性差，大规模网络中效率低。

**第二类：层次路由（Hierarchical Routing）**

层次路由将网络划分为多个层次，最典型的是分簇结构——把节点分成多个小组（簇），每个组选一个组长（簇头），组长负责收集组内数据并上报给基站。

代表协议有：LEACH、HEED、PEGASIS。

这类协议的优点是支持数据融合、可扩展性好；缺点是需要额外的组织开销。

**第三类：地理位置路由（Geographic Routing）**

利用节点的地理位置信息来做路由决策。前提是节点知道自己的位置（通过GPS或定位算法）。

代表协议有：GEAR、GPSR。

这类协议的优点是不需要维护全局路由表，决策效率高；缺点是需要定位能力。

我给大家画一个分类树：

```
WSN路由协议
├── 平面路由（Flat Routing）
│   ├── Flooding（泛洪）
│   ├── Gossiping（闲聊）
│   ├── SPIN（自适应信息传播）
│   └── DD（定向扩散）
├── 层次路由（Hierarchical Routing）
│   ├── LEACH
│   ├── HEED
│   └── PEGASIS
└── 地理位置路由（Geographic Routing）
    ├── GEAR
    └── GPSR
```

今天这节课我们先学平面路由的四种协议。下节课学层次路由和地理位置路由。

好，下面进入第二部分——平面路由协议。

---

## 2.4.2 平面路由协议（60分钟）

### 一、Flooding（泛洪协议）（10分钟）

我们先从最简单的路由协议开始——Flooding，泛洪。

**基本原理**

Flooding的思想非常简单，简单到都不像一个"算法"。它的规则就一条：收到数据包后，转发给除了发送者以外的所有邻居。

我给大家打个比方。想象你在一个大教室里，你想把一句话传给最后一排的同学。你大声喊出来，你周围的同学听到了，也跟着大声喊一遍，一圈一圈向外扩散，就像往水里扔了一块石头，波纹向四面八方扩散。这就是"泛洪"。

具体过程是这样的：

源节点S有一个数据包要发送：
- S把数据包广播给所有邻居A、B、C
- A收到后，广播给自己的所有邻居（除了S）：D、E
- B收到后，广播给自己的所有邻居（除了S）：E、F
- C收到后，广播给自己的所有邻居（除了S）：G
- D、E、F、G继续广播...
- 最终，数据包扩散到整个网络

**Flooding的优点**

首先，它非常简单。不需要任何路由信息，不需要知道网络拓扑，不需要维护路由表。每个节点只需要做一件事：收到数据就转发。

其次，它非常可靠。只要源和目的之间存在一条连通路径，数据包就一定能到达目的地。因为它走的是所有可能的路径。

第三，它不需要任何配置和初始化过程。

**Flooding的三大问题**

但是，Flooding有三个严重的问题：

**第一个问题：信息爆炸（Implosion）**

什么是信息爆炸？就是一个节点会收到同一个数据包的多个副本。

比如，节点E同时是A和B的邻居。A和B都从S那收到了数据包，然后A和B都会把数据包转发给E。结果E就收到了两份一模一样的数据。这是浪费。

在一个密集部署的网络中，一个节点可能会收到同一个数据包的十几个甚至几十个副本。每次接收都消耗能量，这个浪费是很严重的。

**第二个问题：数据重叠（Overlap）**

如果两个相邻的传感器节点监测的是重叠的区域，它们产生的数据本身就有冗余。Flooding不管这个，把冗余数据也一视同仁地泛洪出去，进一步加剧了浪费。

**第三个问题：资源盲目（Resource Blindness）**

Flooding不考虑节点的资源状况。一个快没电的节点和一个电量满满的节点，Flooding对它们一视同仁——都要求转发数据。这可能导致关键节点过早死亡。

所以，Flooding虽然简单可靠，但能耗极高、产生大量冗余，不适合在资源受限的WSN中大规模使用。它更像是一个"保底方案"——在小规模网络或紧急情况下可以用，但不是一个好的长期方案。

### 二、Gossiping（闲聊协议）（8分钟）

Flooding最大的问题是"广播风暴"——每个节点都向所有邻居转发。有没有一种简单的改进方法？

有，就是Gossiping——闲聊协议。

**基本原理**

Gossiping的改进很简单：把"广播给所有邻居"改成"随机选一个邻居转发"。

```
Flooding:  S → {A, B, C, D, E}（发给所有5个邻居）
Gossiping: S → C（随机选1个邻居）
```

为什么叫"闲聊"呢？就像在茶余饭后，一个人随便找一个朋友聊天说"嘿，你听说了吗？"，然后那个朋友又随便找另一个人说，一传十、十传百，消息就慢慢扩散开了。但不是所有人同时喊，而是一个一个地传。

**Gossiping vs Flooding**

与Flooding相比：
- **优点**：大幅减少了信息爆炸的问题。因为每次只发给一个邻居，网络中的数据包副本数量大大减少了。网络负载降低了。
- **缺点**：
  - 传播速度很慢。Flooding是指数级扩散的，Gossiping是线性的。
  - 更严重的是，由于随机选择邻居，数据包可能遗漏某些节点，导致网络中部分节点永远收不到数据。没有覆盖保证。
  - 延迟会增大。

Gossiping适合什么场景呢？适合对实时性要求不高、网络规模不大的场景。

Flooding和Gossiping代表了两个极端：Flooding保证了可靠性但浪费严重，Gossiping节省了能量但牺牲了可靠性和速度。

有没有一种协议能在两者之间找到平衡？先别急着转发，先问问对方需不需要再决定。这就是SPIN协议的核心思想。

### 三、SPIN（自适应信息传播协议）（20分钟）

SPIN是一个非常重要的协议，它的全称是Sensor Protocols for Information via Negotiation——通过协商传播信息的传感器协议。关键词是"协商"。

**设计思想**

Flooding的问题在于"盲目"——不管对方有没有、要不要，直接就发数据。SPIN的改进是：在发送数据之前，先"问一下"对方要不要。

具体怎么实现呢？SPIN引入了**元数据（Metadata）**的概念。每个数据都有一个简短的描述——元数据，它描述了数据的类型、内容摘要等信息。元数据比实际数据小得多。

SPIN的策略是：先发送元数据告诉邻居"我有什么数据"，邻居如果感兴趣并且自己没有这个数据，就请求发送实际数据。这样就避免了发送接收方已有的或不需要的数据。

**三种消息类型**

SPIN定义了三种消息：

1. **ADV（Advertisement，广告消息）**
   - 含义："我有新数据了，要不要？"
   - 内容：数据的元数据描述
   - 用途：通知邻居自己有新数据可以分享

2. **REQ（Request，请求消息）**
   - 含义："要！发给我！"
   - 内容：请求某个数据
   - 用途：表示对某个数据感兴趣，请求发送

3. **DATA（数据消息）**
   - 含义："给你，数据来了！"
   - 内容：实际的传感器数据（附带元数据）
   - 用途：传送实际数据

**三次握手流程——这是SPIN的核心**

大家注意听这个过程，这是重点内容。

假设节点A采集到一个新的数据data_x：

**第一步：ADV（广告）**
节点A向它的邻居们广播一条ADV消息："嘿，我这里有一个新数据data_x，有人需要吗？"注意，ADV里发送的是数据的元数据描述，不是数据本身，所以开销很小。

**第二步：REQ（请求）**
邻居们收到ADV后，各自检查自己的数据库：
- 节点B一看，"data_x？我已经有了，不需要。"——忽略。
- 节点C一看，"data_x？我没有，我需要！"——向A发送REQ消息："A，请把data_x发给我！"
- 节点D也没有data_x，也向A发送REQ。

**第三步：DATA（数据）**
节点A收到C和D的REQ后，把实际数据data_x发送给C和D。

**继续传播**
节点C收到data_x后，它也变成了data_x的持有者。然后C也向自己的邻居发送ADV："嘿，我有data_x了，你们要不要？"这样，数据就一跳一跳地在网络中传播开了。

让我把这个过程画出来：

```
节点A: ──ADV(data_x)──→ 邻居B, C, D
节点B: 已有data_x，忽略
节点C: ←─没有data_x─→ ──REQ(data_x)──→ A
节点D: ←─没有data_x─→ ──REQ(data_x)──→ A
节点A: ──DATA(data_x)──→ C, D
节点C: 收到data_x → ──ADV(data_x)──→ C的邻居们
... 继续传播
```

大家来思考一下，这个三次握手机制解决了Flooding的哪些问题？

第一，解决了信息爆炸问题。如果邻居已经有了这个数据，它收到ADV后不会发REQ，数据就不会被多次发送。

第二，部分解决了数据重叠问题。元数据可以描述数据的内容特征，帮助节点判断是否需要。

**能量感知机制**

SPIN还有一个重要特性——能量感知。

每个节点可以设置一个能量阈值。当节点的剩余能量低于这个阈值时，即使收到了感兴趣的ADV，它也不会发REQ请求数据。因为接收和处理数据也是要消耗能量的，如果电量已经很低了，就不应该再接收新数据了。

这一点是Flooding和Gossiping都没有的。

**SPIN协议族**

SPIN不是单一的协议，而是一个协议族，有多个变种：
- **SPIN-PP**：点对点网络版本，最基本的版本
- **SPIN-EC**：增加了能量阈值约束，即上面说的能量感知机制
- **SPIN-BC**：针对广播网络优化的版本
- **SPIN-RL**：考虑了链路可靠性，增加了重传机制

**SPIN的优缺点**

优点：
1. 协商机制有效减少了冗余数据传输
2. 元数据传输开销很小（远小于实际数据）
3. 支持能量感知，避免能量耗尽
4. 每个节点只需要知道一跳邻居信息，不需要全网拓扑

缺点：
1. 不能保证数据传递到所有感兴趣的节点。为什么？假设节点A和节点C之间隔了一个节点B，而B对data_x不感兴趣。B收到A的ADV后不发REQ，也不会继续传播ADV。结果C永远收不到data_x。
2. ADV-REQ-DATA三步协商有一定的通信开销和延迟

让我们把Flooding、Gossiping和SPIN做个对比：

| 特性     | Flooding | Gossiping | SPIN       |
|----------|----------|-----------|------------|
| 转发策略 | 盲目广播  | 随机单播   | 协商后转发  |
| 冗余程度 | 非常高   | 中等      | 较低        |
| 能量感知 | 无       | 无        | 有          |
| 可靠性   | 高       | 低        | 中          |
| 延迟     | 低       | 高        | 中          |

可以看出，这三种协议体现了一个演进过程：从盲目广播到随机选择再到协商机制，越来越"聪明"。

### 四、DD（定向扩散协议）（18分钟）

接下来我们学习平面路由中的最后一个协议——DD，Directed Diffusion，定向扩散。

DD与前面三种协议有一个根本性的不同。Flooding、Gossiping、SPIN都是"源节点驱动"的——源节点有数据了，主动往外发。而DD是"Sink节点驱动"的——由Sink节点（基站）发起查询，告诉网络"我想要什么数据"。

这体现了我们前面说的"以数据为中心"的思想。

**DD的核心概念**

DD有三个核心概念：

1. **兴趣（Interest）**：Sink节点对数据的需求描述。比如："我想要温度超过50度的数据，每5秒报告一次，持续10分钟，区域是A3。"兴趣消息包含数据类型、报告频率、持续时间、目标区域等属性。

2. **梯度（Gradient）**：从数据源到Sink节点的方向指示。你可以理解为"路标"，告诉数据"往这个方向走可以到达Sink"。梯度是在兴趣消息扩散的过程中自动建立的。

3. **加强（Reinforcement）**：当Sink收到数据后，选择最优路径并"加强"它——让数据更频繁地沿这条路径传输；同时"抑制"其他路径——减少或停止沿这些路径的数据传输。

**DD的三阶段工作过程**

DD的工作分为三个阶段：

**阶段一：兴趣扩散（Interest Propagation）**

首先，Sink节点构造一个兴趣消息，描述它想要的数据。然后把这个兴趣消息广播出去。

Sink广播："我想要温度>50度的数据，区域A3，每5秒一次。"

Sink的邻居节点A、B、C收到这个兴趣后，做两件事：
1. 记录下来："这个兴趣是从Sink那边来的"——这就是**建立梯度**。梯度的方向就是"兴趣来自哪个邻居"，反过来也就是"数据应该往哪个邻居发"。
2. 继续把兴趣消息广播给自己的邻居。

这样，兴趣消息就像Flooding一样扩散到整个网络。但重要的是，在扩散的过程中，每个节点都记录了梯度——"兴趣是从哪个方向来的"。

```
Sink发布兴趣 → A, B, C
A记录：梯度方向→Sink
A转发兴趣 → D, E
D记录：梯度方向→A
E记录：梯度方向→A
...最终兴趣扩散到全网，每个节点都建立了指向Sink的梯度
```

**阶段二：数据传播（Data Propagation）**

当某个源节点（比如节点D）检测到匹配的数据（温度>50度），它就沿梯度的反方向，把数据传回Sink。

D查自己的梯度记录："兴趣是从A来的"——于是把数据发给A。
A查自己的梯度记录："兴趣是从Sink来的"——于是把数据发给Sink。

由于兴趣扩散时走了多条路径，所以梯度可能有多个方向。在这个阶段，数据可能沿多条路径同时传回Sink。这是一个"探索性"的传输阶段，数据传输频率较低（比如每30秒一次），目的是让Sink评估各条路径的质量。

**阶段三：路径加强（Reinforcement）**

Sink通过多条路径收到了数据，它可以评估每条路径的质量——比如哪条路径延迟最短、丢包率最低。

然后，Sink选择最优的那条路径，向这条路径发送"加强"消息——告诉这条路上的节点"把传输频率提高到每5秒一次"。同时，其他路径被"抑制"——降低传输频率或停止传输。

这就像是你家周围有很多条路可以到公司，你先每条路都试试，最后选最快的那条作为每天上班的固定路线。

```
Sink收到来自三条路径的数据：
路径1：D→A→Sink（延迟最低）✓
路径2：D→E→B→Sink（延迟中等）
路径3：D→F→C→Sink（延迟较高）

Sink加强路径1：请每5秒发一次
Sink抑制路径2、3：降低频率
```

**DD的特点**

1. **以数据命名**：不用IP地址，用数据属性描述兴趣（"温度>50度"）
2. **查询驱动**：Sink发起查询，源节点被动响应
3. **多路径探索**：先探索多条路径，再选最优
4. **支持数据融合**：中间节点可以合并来自不同源节点的数据
5. **按需路由**：只有Sink发布兴趣时才建立路由，不浪费资源

**DD vs SPIN对比**

| 特性     | SPIN        | DD            |
|----------|-------------|---------------|
| 发起方   | 源节点      | Sink节点       |
| 模式     | 数据驱动    | 查询驱动       |
| 传播方式 | 逐跳协商    | 全网扩散+路径加强 |
| 数据融合 | 不支持      | 支持           |
| 适用场景 | 数据随时产生 | 按需查询       |

**DD的优缺点**

优点：
- 能量高效：只传输Sink关心的数据
- 支持数据融合：减少传输量
- 多路径：鲁棒性好，一条路径断了还有备选

缺点：
- 兴趣扩散阶段的全网广播开销大
- 不适合持续监测场景（需要反复发布兴趣）
- 梯度维护需要开销
- 对移动Sink支持不好

### 五、平面路由协议小结（2分钟）

好，我们来总结一下今天学的四种平面路由协议。

大家注意它们之间的演进关系：

```
Flooding（盲目广播：简单但浪费）
    ↓ 改进思路：减少广播的数量
Gossiping（随机单播：省能量但慢且不可靠）
    ↓ 改进思路：先问再发
SPIN（协商机制：用元数据减少冗余）
    ↓ 改进思路：让需求方发起，以数据为中心
DD（定向扩散：查询驱动，多路径选优）
```

每一种新协议都是在上一种的基础上解决了某些问题。这也是WSN路由协议研究的一个缩影——不断地在能量效率、可靠性、延迟、可扩展性之间寻找更好的平衡。

但是，平面路由有一个共同的局限——所有节点地位平等，没有层次结构。在大规模网络中，这样的扁平结构效率不高，缺乏有效的数据融合机制。

下节课，我们将学习层次路由协议，看看分簇结构如何解决这些问题。重点会讲LEACH协议，这是WSN中最经典的路由协议之一，大家下课后可以预习一下。

好，今天的课就到这里，下课。

---

# 第二次课（第3-4课时，100分钟）

---

## 2.4.3 层次路由协议（70分钟）

### 一、分簇思想引入（8分钟）

同学们好，上节课我们学习了四种平面路由协议：Flooding、Gossiping、SPIN和DD。大家还记得平面路由的共同特点吗？对，所有节点地位平等。

但是在大规模网络中，平面路由有一些问题。第一，每个节点都参与全网路由，路由维护的通信开销随节点数量增加而增大。第二，缺乏有效的数据融合手段。

我给大家打个比方。假设一个学校有2000个学生，每个学生有什么事都直接去找校长汇报。想象一下校长的状态——被2000个学生围着，根本忙不过来。这就是平面路由在大规模网络中的困境。

怎么解决呢？学校的做法是什么？设立班级结构。每个班选一个班长，学生的事先跟班长说，班长汇总后报给年级主任，年级主任再报给校长。这样校长只需要跟几个年级主任交流，效率大大提高了。

这就是**分簇（Clustering）**的思想。

具体来说，分簇就是把网络中的节点划分为多个小组——簇（Cluster）。每个簇选举一个**簇头（Cluster Head，简称CH）**，其他节点叫做**簇成员（Member）**。

通信过程变成两级：
- **簇内通信**：簇成员把数据发给簇头（短距离通信）
- **簇间通信**：簇头把汇总后的数据发给基站（长距离通信）

```
┌──────────────────────────────────┐
│            基站（BS）              │
│           ↗    ↑    ↖            │
│    ┌────┐  ┌────┐  ┌────┐       │
│    │簇头1│  │簇头2│  │簇头3│       │
│    │↗↑↖│  │↗↑↖│  │↗↑↖│       │
│    │成员 │  │成员 │  │成员 │       │
│    └────┘  └────┘  └────┘       │
└──────────────────────────────────┘
```

分簇有四大优势：

1. **减少通信距离**：簇内通信是短距离的，能耗低。无线通信能耗与距离的平方甚至四次方成正比，距离缩短一半，能耗可以降到原来的1/4。

2. **数据融合**：簇头可以把簇内多个成员的数据合并、压缩后再发送。比如10个温度传感器各传一个数据，簇头可以只传一个平均值，数据量减少90%。

3. **可扩展性**：网络被分成多个独立管理的簇，每个簇内部独立运作。即使网络规模增大，每个簇的管理复杂度不变。

4. **负载均衡**：通过定期轮换簇头，避免固定节点承担过多转发任务而提前死亡。

好，分簇的思想明白了。下面我们学习最经典的分簇路由协议——LEACH。

### 二、LEACH协议（35分钟）

**LEACH概述**

LEACH的全称是Low-Energy Adaptive Clustering Hierarchy——低能耗自适应分簇层次协议。它是2000年由MIT的Heinzelman等人提出的，是WSN中最经典、被引用最多的路由协议之一。

LEACH的核心思想用一句话概括就是：**分簇 + 簇头轮换**。把网络分成簇，选出簇头来做数据收集和融合，但簇头不是固定的，每过一段时间重新选一次，大家轮流当，这样就均衡了能量消耗。

LEACH的工作过程分为很多轮（Round），每一轮分为两个阶段：**建立阶段（Setup Phase）**和**稳定阶段（Steady Phase）**。建立阶段负责选簇头、组建簇；稳定阶段负责传输数据。稳定阶段的时间远长于建立阶段，以减少组织开销。

下面我们详细讲这两个阶段。

**阶段一：建立阶段（Setup Phase）**

建立阶段要完成四件事：簇头选举、簇头广播、成员加入、时隙分配。

**步骤1：簇头选举**

这是LEACH最核心的机制。簇头的选举是完全分布式的——每个节点自己决定自己是不是簇头，不需要集中控制。

怎么决定呢？很简单，每个节点生成一个0到1之间的随机数，如果这个随机数小于一个阈值T(n)，那么这个节点就自告奋勇成为簇头。

阈值T(n)的公式是：

**T(n) = p / (1 - p × (r mod 1/p))**

其中：
- p是期望的簇头比例，通常设为5%，也就是平均每20个节点选出1个簇头
- r是当前的轮数（第几轮）
- n必须是本轮还没当过簇头的节点

这个公式大家不需要推导，理解它的含义就行。它保证了两点：

第一，每一轮大约有p比例的节点成为簇头。如果p=5%，有100个节点，那么每轮大约有5个簇头。

第二，已经当过簇头的节点在当前周期内不会再当。怎么实现的？已当过簇头的节点，T(n)直接设为0——随机数不可能小于0，所以肯定不会被选上。这就保证了在1/p轮内（20轮），所有节点都会轮流当一次簇头。

我来举个具体的例子。假设有100个节点，p=0.05。

- 第0轮：所有100个节点都有资格。T(n) = 0.05/(1-0.05×0) = 0.05。每个节点有5%的概率成为簇头，大约5个节点当选。
- 第1轮：上一轮的5个簇头T(n)=0，不参选。剩下95个节点参选，T(n) = 0.05/(1-0.05×1) ≈ 0.053。概率稍微提高了一点，保证大约5个节点当选。
- 第2轮：已有10个节点当过簇头了。T(n) = 0.05/(1-0.05×2) ≈ 0.056。
- ...
- 第19轮：已有95个节点当过簇头。剩下5个节点，T(n) = 0.05/(1-0.05×19) = 1。概率为1，这5个节点必定成为簇头。

20轮后，所有节点都当过一次簇头，开始新的周期。这就是"公平轮换"的机制。

**步骤2：簇头广播**

选出的簇头向全网广播一条消息："我是簇头！"这个广播用较大的发射功率，确保所有节点都能收到。

**步骤3：成员加入**

普通节点（非簇头）收到可能来自多个簇头的广播。它选择信号最强的那个簇头（通常就是距离最近的），向该簇头发送一条"加入请求"消息。

选择最近的簇头有什么好处？簇内通信距离最短，能耗最低。

**步骤4：时隙分配**

簇头收到所有加入请求后，知道了自己管辖的成员有哪些。然后簇头建立一个TDMA（时分多址）调度表，给每个成员分配一个发送时隙，并广播给所有成员。

为什么用TDMA？因为簇内多个成员需要向簇头发送数据，TDMA确保同一时间只有一个成员在发送，避免冲突。

好，建立阶段完成了。现在每个簇都已经组建好了：有一个簇头，若干个成员，还有一个TDMA调度表。

**阶段二：稳定阶段（Steady Phase）**

稳定阶段是实际传输数据的阶段，时间比建立阶段长得多。

**步骤5：簇内数据传输**

每个簇成员按TDMA调度表分配的时隙，向簇头发送自己采集的数据。在不是自己时隙的时候，成员节点可以关闭无线模块进入睡眠状态，节省能量。

这里大家注意一下——上节课我们学的S-MAC协议也用了类似的周期性睡眠机制。LEACH的TDMA调度和MAC层的调度是相辅相成的。

**步骤6：数据融合**

簇头收集完所有成员的数据后，对数据进行融合处理。比如：
- 去除冗余：10个节点测到相似的温度值，取平均
- 数据压缩：减少数据量
- 异常检测：去除明显错误的值

数据融合可以显著减少从簇头到基站的传输数据量。

**步骤7：簇头向基站传输**

簇头将融合后的数据直接发送给基站。注意LEACH中簇头是"直接"通信到基站的，即一跳传输，不经过其他簇头中转。

**一轮结束**

稳定阶段持续一段时间后，当前轮结束，重新回到建立阶段——重新选举簇头、组建簇。新一轮开始。

这就是LEACH的完整工作过程。我把两个阶段的时间线画出来：

```
│←─建立阶段─→│←────────── 稳定阶段 ──────────→│
│ 簇头选举    │ 数据传输  数据传输  数据传输  ...│
│ 簇形成      │ 数据融合  数据融合  数据融合  ...│
│ TDMA分配    │ 簇头→BS   簇头→BS   簇头→BS  ...│
│                                               │
│←───────────── 一轮（Round）─────────────────→│
```

**LEACH的能量分析**

我们来分析一下为什么LEACH能节省能量。

先看三种方案的对比：

**方案一：直接传输**
每个节点直接向基站发送数据。如果基站很远，每个节点都要消耗很大的能量进行长距离传输。而且每个节点发送的数据没有经过融合，总传输量很大。

**方案二：多跳传输**
数据通过多跳转发到基站。靠近基站的节点需要承担大量转发任务，能量消耗特别大，会过早死亡。

**方案三：LEACH**
成员→簇头（短距离，能耗低）→ 数据融合（减少数据量）→ 簇头→基站（只有簇头承担长距离通信）+ 簇头轮换（均衡能耗）。

LEACH节省能量的三个原因：
1. **簇内通信距离短**：能耗与距离的平方成正比，距离短一半，能耗降为1/4
2. **数据融合**：减少了传输数据量
3. **簇头轮换**：避免固定节点承担重任而提前死亡，均衡全网能耗

**LEACH的局限性**

LEACH虽然经典，但也有一些问题：

1. **簇头选举是随机的**，不考虑节点的剩余能量。可能选到一个电量很低的节点当簇头，而簇头的能耗是最大的——要接收所有成员数据、做融合、远距离发给基站。如果簇头的电量不足，整个簇就瘫痪了。

2. **簇头直接与基站通信**。如果基站很远，簇头需要很大的发射功率。这对远离基站的簇头不公平——它们消耗的能量比靠近基站的簇头多得多。

3. **假设所有节点都能直接到达基站**。在大规模网络中，这个假设不成立。

4. **簇的大小可能不均匀**。由于簇头是随机选的，可能出现某些区域簇头密集、某些区域没有簇头的情况。

5. **不适合节点移动的场景**。LEACH假设节点静止。

这些问题催生了后续的改进协议。下面我们简要介绍两个重要的改进：HEED和PEGASIS。

### 三、HEED协议简介（10分钟）

**HEED概述**

HEED的全称是Hybrid Energy-Efficient Distributed Clustering——混合能量高效分布式分簇协议。

HEED是对LEACH的一个重要改进，主要解决的是LEACH中"簇头随机选举"的问题。

大家想一想LEACH簇头选举的问题在哪里。对，它是随机的，不考虑节点的能量状况。一个电量只剩10%的节点和一个满电量的节点，被选为簇头的概率是一样的。这不合理。

HEED的改进是：**让能量多的节点更有可能成为簇头**。

**HEED的簇头选举机制**

HEED用两个参数来决定簇头的选举：

1. **主参数：节点的剩余能量**
   - 剩余能量越多的节点，成为簇头的概率越大
   - 计算方式：CH_prob = C_prob × (E_residual / E_max)
   - 其中E_residual是当前剩余能量，E_max是初始最大能量
   - 这样满电量节点的概率最大，快没电的节点概率趋近于0

2. **副参数：簇内通信代价**
   - 考虑候选簇头周围的节点密度
   - 选择使簇内通信总代价最小的节点
   - 通俗地说，就是选那些"位置好"的节点——周围邻居多，当簇头最方便

这两个参数结合起来，HEED选出的簇头既是"能量充沛的"，又是"位置合适的"。

**HEED vs LEACH对比**

| 特性       | LEACH          | HEED              |
|------------|----------------|-------------------|
| 簇头选择标准 | 随机数 vs 阈值 | 剩余能量 + 通信代价 |
| 能量考虑   | 不考虑          | 首要考虑           |
| 簇头分布   | 可能不均匀      | 更加均匀           |
| 能量均衡   | 一般            | 更好               |
| 计算开销   | 低              | 较高               |
| 终止保证   | 确定的          | O(1)轮内保证终止   |

HEED的主要优势就是更加"智能"地选择簇头，让网络的生命周期更长。

但HEED也有不足——簇头选举过程中需要多轮迭代和更多的消息交换，通信开销比LEACH大。而且HEED仍然采用簇头直接到基站的通信方式，距离远时问题依然存在。

### 四、PEGASIS协议简介（10分钟）

**PEGASIS概述**

PEGASIS的全称是Power-Efficient GAthering in Sensor Information Systems——能量高效的传感器信息收集系统。

PEGASIS是另一种改进LEACH的思路——它不是改进簇头选举算法，而是**改变网络结构**：从星型结构变成链式结构。

**从LEACH到PEGASIS的思路**

LEACH中，每个簇是一个星型结构——所有成员把数据发给中心的簇头。这意味着有些成员可能距离簇头比较远，需要较大的发射功率。

PEGASIS的想法是：如果每个节点只需要和最近的邻居通信，就能大大降低通信距离和能耗。

**PEGASIS的工作方式**

PEGASIS把所有节点组织成一条链（Chain）：

```
LEACH（星型结构）：
成员1 ─→ ┐
成员2 ─→ ├→ 簇头 ──→ 基站
成员3 ─→ ┘
成员4 ─→ ┘

PEGASIS（链式结构）：
节点1 → 节点2 → 节点3 → 节点4 → ... → 链头 → 基站
```

链的构建过程：
1. 从距离基站最远的节点开始
2. 用贪心算法，每次选择最近的未加入链的节点
3. 最终所有节点连成一条链

数据传输过程：
1. 每一轮选择一个链头（Leader），负责向基站传输
2. 链头轮流担任（第r轮的链头是第r mod N个节点，N为节点总数）
3. 数据从链的两端向链头方向传递
4. 每个节点收到上一个节点的数据后，与自己的数据融合，再传给下一个节点
5. 数据在链上逐步融合，到达链头时已经高度压缩
6. 链头把融合后的数据发送给基站

**PEGASIS的优势**

1. **每个节点只和最近邻居通信**：通信距离很短，能耗很低
2. **链上逐步数据融合**：数据在传输过程中不断被融合压缩
3. **链头轮换**：和LEACH一样，避免固定节点负担过重
4. **减少了通信量**：相比LEACH，每轮只有一个节点（链头）向基站传输

**PEGASIS vs LEACH对比**

| 特性       | LEACH          | PEGASIS         |
|------------|----------------|-----------------|
| 网络结构   | 星型（簇）      | 链式            |
| 通信范围   | 成员到簇头      | 最近邻居        |
| 数据融合   | 簇头集中融合    | 链上逐步融合    |
| 向BS通信   | 每簇1个簇头     | 全网1个链头     |
| 能耗       | 较低            | 更低            |

**PEGASIS的局限性**

1. **延迟较大**：数据要沿着链从一端传到另一端，再传到基站。如果链很长，延迟很大。
2. **链的构建需要全局信息**：贪心算法需要知道所有节点的位置，这在大规模网络中不现实。
3. **链头瓶颈**：链头负责向基站传输所有融合后的数据，如果距离基站很远，能耗大。
4. **不适合动态拓扑**：节点故障会导致链断裂，需要重新构建链。

我给大家总结一下这三种层次路由协议的关系：

LEACH是开创者——提出了分簇和簇头轮换的思想。HEED在LEACH基础上改进了簇头选举策略——让能量多的节点优先当簇头。PEGASIS则另辟蹊径——把星型结构改成链式结构，进一步降低通信距离。

### 五、层次路由协议小结（7分钟）

我们来把三种层次路由协议做一个全面的对比：

| 特性       | LEACH          | HEED           | PEGASIS        |
|------------|----------------|----------------|----------------|
| 提出时间   | 2000年         | 2004年         | 2002年         |
| 网络结构   | 簇（星型）      | 簇（星型）      | 链式           |
| 簇头/链头  | 随机选举        | 基于能量选举    | 贪心+轮换      |
| 数据融合   | 簇头集中融合    | 簇头集中融合    | 链上逐步融合    |
| 到BS方式   | 簇头直接到BS    | 簇头直接到BS    | 链头直接到BS    |
| 能量均衡   | 一般            | 较好           | 较好            |
| 延迟       | 中             | 中             | 高              |
| 可扩展性   | 好             | 好             | 中              |
| 适用场景   | 周期性数据采集  | 能量敏感场景   | 链式数据收集    |

层次路由的核心优势是什么？两点：**数据融合**和**减少传输距离**。

通过分簇或成链，把远距离通信变成了短距离通信（簇内/链内），再加上数据融合减少传输量，整体能耗大幅降低。

层次路由的共同问题是什么？**簇头/链头到基站的长距离通信**。这三个协议的簇头/链头都是直接和基站通信的。如果基站很远，这个长距离传输的能耗就很大。后续研究中有一些改进方案，比如多跳的簇间路由、簇头之间建立路由树等，但这些超出我们本节课的范围。

好，层次路由讲完了。下面我们来看最后一类——地理位置路由。

---

## 2.4.4 地理位置路由与总结（30分钟）

### 一、地理位置路由简介（12分钟）

**基本思想**

前面的路由协议，不管是平面路由还是层次路由，都不需要节点知道自己的地理位置。但如果节点知道自己的位置（通过GPS或定位算法），我们就可以利用这个位置信息来做更高效的路由决策。

这就是地理位置路由的核心思想：**利用节点的地理位置信息来选择下一跳**。

它的最大优势是：不需要维护全局路由表。每个节点只需要知道自己的位置、邻居的位置和目标的位置，就可以做出路由决策。这是完全局部的决策，通信开销很小，可扩展性非常好。

下面我们简要介绍两个代表性的地理位置路由协议。

**GEAR协议**

GEAR的全称是Geographic and Energy Aware Routing——地理和能量感知路由。

GEAR结合了两个因素来做路由：地理位置和节点能量。

GEAR的工作分为两个阶段：

第一阶段：**将数据转发到目标区域**
- Sink发布一个查询，指定目标区域（比如"A区的温度数据"）
- 数据包沿着地理方向转发向目标区域
- 选择下一跳时，综合考虑：
  - 邻居到目标区域的距离（越近越好）
  - 邻居的剩余能量（越多越好）
- 如果存在"空洞"（没有更近的邻居），采用替代策略绕过

第二阶段：**在目标区域内扩散数据查询**
- 数据包到达目标区域后
- 在区域内扩散查询消息
- 匹配的节点响应数据

GEAR的优势在于能量感知——不仅选择地理上最优的路径，还考虑了节点能量，避免总是走同一条路导致某些节点过早死亡。

**GPSR协议**

GPSR的全称是Greedy Perimeter Stateless Routing——贪心周边无状态路由。

GPSR有两种工作模式：

**模式一：贪心模式（Greedy Forwarding）**

最简单直接的思路：每一跳都选择距离目标最近的邻居转发。

比如当前节点X要发数据给目标T，X的邻居有A、B、C。X计算A、B、C到T的距离，选最近的那个转发。假设B距离T最近，就发给B。B再用同样的策略继续转发。

```
X → B → E → ... → T（每一跳都选离T最近的邻居）
```

贪心模式大多数情况下效果很好，但有一个问题——**空洞（Void/Hole）**。

**什么是空洞？**

空洞就是这种情况：当前节点X的所有邻居，没有一个比X更靠近目标T。也就是说，在X的通信范围内，X已经是离T最近的了。

这时候贪心模式就"卡住"了——无论发给哪个邻居，都是在远离目标。

**模式二：周边模式（Perimeter Forwarding）**

遇到空洞时，GPSR切换到周边模式。

在周边模式下，数据包沿着空洞的边界转发。具体使用的是"右手法则"——想象你把右手贴着墙走，最终一定能走出这个区域。

一旦数据包到达一个比空洞入口更靠近目标的节点，就切回贪心模式继续转发。

```
贪心模式：X → ... → V（卡住，V是空洞入口）
周边模式：V → 沿空洞边界 → W（W比V更靠近T）
贪心模式：W → ... → T（恢复正常）
```

**地理位置路由的优缺点总结**

优点：
1. 不需要全局路由表——每个节点只需局部信息
2. 可扩展性好——路由决策是完全局部的
3. 对拓扑变化适应性好——不需要重建路由
4. 通信开销小——不需要路由维护消息

缺点：
1. 需要节点有定位能力——GPS成本高、室内不可用
2. 位置信息可能不精确——影响路由质量
3. 空洞问题——处理复杂
4. 不适合没有位置信息的场景

### 二、协议综合对比（10分钟）

好，到这里我们已经学完了三大类WSN路由协议。现在我们来做一个全面的对比和总结。

**全部协议对比表**

| 协议     | 类型   | 能效 | 延迟 | 可扩展性 | 数据融合 | 适用场景         |
|----------|--------|------|------|----------|----------|-----------------|
| Flooding | 平面   | 低   | 低   | 差       | 无       | 极小网络/紧急广播 |
| Gossiping| 平面   | 中   | 高   | 差       | 无       | 小规模/非实时    |
| SPIN     | 平面   | 中   | 中   | 中       | 无       | 数据驱动场景     |
| DD       | 平面   | 高   | 中   | 中       | 有       | 查询驱动场景     |
| LEACH    | 层次   | 高   | 中   | 好       | 有       | 周期性数据采集   |
| HEED     | 层次   | 高   | 中   | 好       | 有       | 能量敏感场景     |
| PEGASIS  | 层次   | 高   | 高   | 中       | 有       | 链式数据收集     |
| GEAR     | 地理   | 高   | 低   | 好       | 有       | 有位置信息的场景 |
| GPSR     | 地理   | 高   | 低   | 好       | 无       | 有位置信息的场景 |

大家可以看到一些规律：
- 从左到右，协议越来越"智能"，能效越来越高
- 层次路由和地理位置路由普遍优于平面路由
- 没有一种协议在所有指标上都是最优的——都有各自的适用场景

**协议选择指南**

在实际应用中怎么选择呢？

1. **小规模网络，简单应用** → Flooding或Gossiping
   - 节点少，广播开销可以接受

2. **数据驱动场景** → SPIN
   - 节点主动产生数据并传播

3. **查询驱动场景** → DD
   - Sink按需查询特定数据

4. **大规模网络，周期性采集** → LEACH / HEED
   - 节点定期上报数据，需要数据融合

5. **节点有GPS定位能力** → GEAR / GPSR
   - 利用位置信息做高效路由

实际上，很多实际的WSN系统会结合多种路由策略。比如用分簇结构管理网络，在簇间使用地理位置路由。

### 三、知识框架总结（5分钟）

我们来回顾一下2.4节学到的全部内容。

```
2.4 网络层技术介绍
│
├── 2.4.1 概述与基础
│   ├── 网络层在WSN中的作用
│   ├── 传统路由基础（路由表、DV、LS）
│   ├── WSN路由的五大挑战
│   │   ├── 能量受限
│   │   ├── 拓扑动态
│   │   ├── 数据冗余
│   │   ├── 以数据为中心
│   │   └── 可扩展性
│   └── 路由协议三大分类
│
├── 2.4.2 平面路由协议
│   ├── Flooding → Gossiping → SPIN → DD（演进关系）
│   ├── SPIN三次握手：ADV-REQ-DATA ★★
│   └── DD三阶段：兴趣扩散-数据传播-路径加强 ★
│
├── 2.4.3 层次路由协议
│   ├── 分簇思想
│   ├── LEACH：分簇+簇头轮换 ★★（核心）
│   │   ├── 建立阶段：簇头选举→广播→加入→时隙分配
│   │   └── 稳定阶段：数据传输→融合→上报
│   ├── HEED：基于能量的簇头选举
│   └── PEGASIS：链式结构
│
└── 2.4.4 地理位置路由与总结
    ├── GEAR：地理+能量感知
    ├── GPSR：贪心+周边转发
    └── 协议对比总结
```

从这两节课的学习中，大家需要掌握的核心要点有：

1. WSN路由与传统路由的本质区别——**以数据为中心、能量优先**
2. 平面路由四种协议的工作原理和演进关系
3. **SPIN的三次握手机制**：ADV-REQ-DATA（重点）
4. **LEACH的两阶段工作过程**：建立阶段和稳定阶段（重点）
5. 三类路由协议的适用场景和选择依据

### 四、衔接下一章（3分钟）

好，到这里我们就完成了网络层的学习。

让我们回顾一下，在第二章"传感器网络通信技术"中，我们已经学了哪些内容：

- 2.1节：了解了OSI参考模型和WSN的协议架构
- 2.2节：学了物理层——无线信号怎么传输
- 2.3节：学了MAC层——相邻节点怎么共享信道
- 2.4节：学了网络层——数据怎么从源头路由到基站

从下到上，我们已经建立了一个完整的通信链路。数据从传感器产生，通过物理层编码调制成无线信号发出去，MAC层保证了在共享信道上有序通信，网络层找到了从源到目的的路由路径。

接下来我们将进入更上层的内容，包括传输层和应用层。传输层关心的是数据传输的可靠性和拥塞控制，应用层关心的是具体的应用需求。

同学们课后请复习今天的内容，重点掌握SPIN和LEACH这两个协议的工作机制。

好，今天的课就到这里，下课！

---

## 附录：常见问题预备

### Q1：LEACH的T(n)公式为什么能保证均匀轮换？
**A**：设p=0.05（5%），则一个完整周期是1/p=20轮。在第0轮，所有节点参选，T(n)=0.05，约5%的节点当选。已当选节点在剩余轮中T(n)=0，退出参选。随着轮数增加，候选节点减少，T(n)逐渐增大，保证每轮仍约有p比例当选。到第19轮，仅剩最后几个节点，T(n)=1，必定当选。这样20轮内所有节点恰好各当一次簇头。

### Q2：DD和SPIN的最大区别是什么？
**A**：发起方不同。SPIN是源节点驱动——"我有数据，你要不要？"。DD是Sink驱动——"我要数据，谁有？"。DD更适合按需查询的场景，SPIN更适合数据随时产生的场景。

### Q3：为什么不直接给所有WSN节点分配IP地址用传统路由？
**A**：三个原因：(1)节点数量大，IP地址管理复杂；(2)传统路由需要维护路由表，消耗内存和能量；(3)WSN的通信模式是多对一汇聚，不是点对点，以数据为中心比以地址为中心更高效。

### Q4：GPSR遇到空洞为什么不直接绕过？
**A**：因为节点不知道空洞的形状和范围，没有全局信息。右手法则（周边转发）是一种只依赖局部信息就能保证绕过空洞的方法。虽然路径不一定最短，但保证了数据最终能到达目标。

### Q5：实际WSN系统中用哪种路由协议最多？
**A**：没有统一答案，取决于应用场景。但分簇路由（LEACH及其改进）在学术研究中被引用最多。实际部署中，很多系统根据具体需求定制路由方案，往往融合了多种协议的思想。
